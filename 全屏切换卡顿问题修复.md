# 全屏切换续播卡顿问题修复

## 问题描述

用户将视频全屏化后，视频会重新自动加载续播，但是视频一直卡在续播那一帧里，无法继续播放。

## 问题原因

全屏切换时的恢复逻辑过于激进，导致以下问题：

1. **过早执行 seekTo**
   - 第一次恢复就执行 `pause()` + `start()`
   - 可能与续播的 `seekTo` 冲突

2. **频繁的 seekTo 调用**
   - 第二次检查执行 `seekTo(currentPosition + 100)`
   - 第三次检查执行 `seekTo(currentPosition)`
   - 多次 `seekTo` 导致播放器状态混乱

3. **不检查位置变化**
   - 即使位置正常变化，也会执行 `seekTo`
   - 导致播放器被强制跳转，卡在某一帧

## 修复方案

### 核心思路

**只在真正需要时才执行 seekTo，优先使用 start() 恢复播放**

### 第一次恢复（200ms后）

```kotlin
// 不执行 seekTo，只检查播放状态
if (wasPlaying) {
    if (!exoManager.isPlaying()) {
        Log.d(TAG, "播放器未播放，直接启动")
        exoManager.start() // 直接启动，不执行 seekTo
    } else {
        Log.d(TAG, "播放器已在播放，保持状态")
    }
}
```

**改进：**
- ❌ 移除 `pause()` + `start()` 的组合
- ✅ 只在未播放时调用 `start()`
- ✅ 如果已在播放，保持状态不变
- ✅ 缩短延迟到 200ms

### 第二次检查（600ms后）

```kotlin
// 检查位置变化，只在完全没变化时才微调
val newPosition = exoManager.getCurrentPosition()
val positionDiff = kotlin.math.abs(newPosition - currentPosition)

// 只有在位置完全一样且时间已过去一段时间时，才认为可能卡住
if (positionDiff == 0L && currentPosition > 0 && wasPlaying) {
    Log.w(TAG, "检测到位置完全未变化，可能卡住，尝试微调位置")
    // 微调位置，触发播放器更新（向前微调 50ms）
    exoManager.seekTo(currentPosition + 50)
    // 微调后立即启动播放
    Handler.postDelayed({
        if (!exoManager.isPlaying() && wasPlaying) {
            exoManager.start()
        }
    }, 100)
} else {
    Log.d(TAG, "位置正常变化: $currentPosition -> $newPosition (差值: $positionDiff ms)")
}
```

**改进：**
- ✅ 计算位置差值 `positionDiff`
- ✅ 只在差值为 0 时才认为卡住
- ✅ 微调量从 100ms 减少到 50ms
- ✅ 记录位置变化情况
- ✅ 缩短延迟到 600ms

### 第三次检查（1200ms后）

```kotlin
val finalPosition = exoManager.getCurrentPosition()
val finalDiff = kotlin.math.abs(finalPosition - currentPosition)

// 只有在位置完全没变化且应该播放时，才执行最终恢复
if (wasPlaying && !exoManager.isPlaying()) {
    // 如果位置完全没变化，可能真的卡住了
    if (finalDiff == 0L) {
        Log.w(TAG, "位置完全未变化，执行 seekTo 恢复")
        exoManager.seekTo(currentPosition)
        Handler.postDelayed({
            exoManager.start()
        }, 100)
    } else {
        // 位置有变化，只需要启动播放
        Log.d(TAG, "位置有变化，只启动播放")
        exoManager.start() // 不执行 seekTo
    }
} else {
    Log.d(TAG, "播放器状态正常，位置变化: $currentPosition -> $finalPosition")
}
```

**改进：**
- ✅ 检查最终位置差值
- ✅ 只在差值为 0 时执行 `seekTo`
- ✅ 如果位置有变化，只调用 `start()`
- ✅ 记录详细的状态信息
- ✅ 缩短延迟到 1200ms

## 时间线对比

### 修复前
```
全屏切换
    ↓
300ms  → pause() + start() (可能与续播冲突)
    ↓
800ms  → seekTo(currentPosition + 100) (强制跳转)
    ↓
1500ms → seekTo(currentPosition) (再次强制跳转)
    ↓
2000ms → 取消标记
```

### 修复后
```
全屏切换
    ↓
200ms  → 只 start()，不 seekTo (避免冲突)
    ↓
600ms  → 检查位置差值，只在差值为 0 时微调
    ↓
1200ms → 检查最终差值，只在差值为 0 时 seekTo
    ↓
1500ms → 取消标记
```

## 关键改进

### 1. 减少 seekTo 调用

**修复前：**
- 第一次：`pause()` + `start()`（可能触发内部 seekTo）
- 第二次：`seekTo(currentPosition + 100)`
- 第三次：`seekTo(currentPosition)`

**修复后：**
- 第一次：只 `start()`
- 第二次：只在差值为 0 时 `seekTo(currentPosition + 50)`
- 第三次：只在差值为 0 时 `seekTo(currentPosition)`

### 2. 检查位置变化

```kotlin
val positionDiff = kotlin.math.abs(newPosition - currentPosition)
if (positionDiff == 0L) {
    // 真的卡住了
} else {
    // 位置正常变化，不需要 seekTo
}
```

### 3. 缩短延迟时间

- 第一次：300ms → 200ms
- 第二次：800ms → 600ms
- 第三次：1500ms → 1200ms
- 标记取消：2000ms → 1500ms

### 4. 详细日志

```kotlin
Log.d(TAG, "位置正常变化: $currentPosition -> $newPosition (差值: $positionDiff ms)")
Log.d(TAG, "播放器状态正常，位置变化: $currentPosition -> $finalPosition")
```

## 测试建议

### 测试场景

1. **续播场景**
   - ✅ 打开之前播放过的视频
   - ✅ 全屏化
   - ✅ 应该从续播位置继续播放

2. **正常播放场景**
   - ✅ 播放新视频
   - ✅ 全屏化
   - ✅ 应该继续播放

3. **暂停场景**
   - ✅ 暂停视频
   - ✅ 全屏化
   - ✅ 应该保持暂停

### 日志检查

正常情况应该看到：
```
全屏模式切换: isFullscreen=true, 切换前播放状态: wasPlaying=true, 位置: 12345
全屏切换后第一次恢复尝试...
播放器已在播放，保持状态
全屏切换后第二次检查...
位置正常变化: 12345 -> 12800 (差值: 455 ms)
全屏切换后第三次检查...
播放器状态正常，位置变化: 12345 -> 13500
全屏切换标记已取消
```

卡住的情况会看到：
```
全屏模式切换: isFullscreen=true, 切换前播放状态: wasPlaying=true, 位置: 12345
全屏切换后第一次恢复尝试...
播放器未播放，直接启动
全屏切换后第二次检查...
检测到位置完全未变化，可能卡住，尝试微调位置
全屏切换后第三次检查...
位置完全未变化，执行 seekTo 恢复
最终恢复完成
```

## 总结

通过减少不必要的 `seekTo` 调用和检查位置变化，全屏切换后的续播卡顿问题应该得到解决：

- ✅ **优先使用 start()**：避免与续播的 seekTo 冲突
- ✅ **检查位置变化**：只在真正卡住时才执行 seekTo
- ✅ **减少微调量**：从 100ms 减少到 50ms
- ✅ **缩短延迟**：更快的响应时间
- ✅ **详细日志**：便于调试和诊断

现在可以测试全屏切换功能了！🎉
