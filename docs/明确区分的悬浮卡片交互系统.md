# 明确区分的悬浮卡片交互系统

## 🎯 功能概述

全新设计的悬浮卡片交互系统，明确区分三种不同的操作动作，避免混淆：

1. **长按激活** → 激活悬浮卡片显示
2. **继续长按 + 左右滑动** → 控制悬浮卡片左右滑动
3. **手指脱离屏幕** → 打开正中间的卡片

## 🚀 详细交互流程

### 阶段1：长按激活悬浮卡片
```
在tab区域长按 → 达到500ms阈值 → 激活悬浮卡片显示
```

**操作方式**：
- 在tab区域（WebView容器）按下手指
- 保持按压状态500ms
- 系统自动激活悬浮卡片显示

**视觉反馈**：
- 显示所有网页卡片的平行排列
- 第一张卡片位于正中间
- 中心卡片最大最亮，边缘卡片较小较暗

**技术实现**：
```kotlin
// 检查是否达到长按时间
if (!isLongPressActivated && (currentTime - longPressStartTime) >= longPressThreshold) {
    isLongPressActivated = true
    Log.d("StackedCardPreview", "长按激活成功！悬浮卡片已显示")
}
```

### 阶段2：继续长按 + 左右滑动
```
保持长按状态 → 左右滑动手指 → 悬浮卡片跟随滑动
```

**操作方式**：
- 在长按激活后，继续保持手指按压
- 左右滑动手指控制卡片移动
- 实时切换中心卡片

**视觉反馈**：
- 卡片跟随手指滑动
- 中心卡片实时变化
- 平滑的缩放和透明度过渡

**技术实现**：
```kotlin
// 只有在长按激活后才能进行滑动操作
if (isLongPressActivated) {
    if (abs(deltaX) > abs(deltaY)) {
        isLongPressSliding = true
        handleLongPressSlide(deltaX)
    }
}
```

### 阶段3：手指脱离屏幕打开卡片
```
手指脱离屏幕 → 自动对齐到最近卡片 → 打开正中间的卡片
```

**操作方式**：
- 手指离开屏幕（ACTION_UP事件）
- 系统自动处理后续操作

**自动化流程**：
1. **自动对齐**：200ms平滑对齐到最近的卡片
2. **立即打开**：对齐完成后自动打开中间卡片
3. **切换网页**：切换到选中的网页并隐藏预览

**技术实现**：
```kotlin
MotionEvent.ACTION_UP -> {
    if (isLongPressActivated) {
        if (isLongPressSliding) {
            // 长按滑动结束，打开正中间的卡片
            snapToNearestCardAndOpen()
        } else {
            // 长按但没有滑动，直接打开当前中心卡片
            selectCurrentCard()
        }
    }
}
```

## 🎮 三种动作的明确区分

### 1. 长按激活 vs 普通点击
| 特性 | 普通点击 | 长按激活 |
|------|---------|----------|
| 时间要求 | 瞬间 | ≥500ms |
| 触发条件 | 立即释放 | 持续按压 |
| 系统响应 | 无响应 | 激活悬浮卡片 |
| 后续操作 | 无 | 可以继续滑动 |

### 2. 长按滑动 vs 普通滑动
| 特性 | 普通滑动 | 长按滑动 |
|------|---------|----------|
| 前置条件 | 无 | 必须先长按激活 |
| 激活状态 | isLongPressActivated = false | isLongPressActivated = true |
| 系统响应 | 无响应 | 控制悬浮卡片 |
| 滑动检测 | 忽略 | isLongPressSliding = true |

### 3. 手指脱离 vs 继续按压
| 特性 | 继续按压 | 手指脱离 |
|------|---------|----------|
| 事件类型 | ACTION_MOVE | ACTION_UP |
| 系统行为 | 继续滑动控制 | 自动对齐并打开 |
| 卡片状态 | 继续移动 | 停止移动 |
| 最终结果 | 无变化 | 打开中间卡片 |

## 🔧 技术实现细节

### 状态管理系统
```kotlin
// 长按激活相关
private var isLongPressActivated = false // 是否已通过长按激活
private var longPressStartTime = 0L // 长按开始时间
private val longPressThreshold = 500L // 长按阈值（毫秒）

// 长按滑动相关
private var isLongPressSliding = false // 是否在长按滑动状态
private var slideStartX = 0f
private var slideStartY = 0f
```

### 触摸事件处理流程
```kotlin
ACTION_DOWN -> {
    // 记录按压开始时间
    longPressStartTime = System.currentTimeMillis()
    isLongPressSliding = false
}

ACTION_MOVE -> {
    // 检查是否达到长按时间
    if (!isLongPressActivated && (currentTime - longPressStartTime) >= longPressThreshold) {
        isLongPressActivated = true
    }
    
    // 只有激活后才能滑动
    if (isLongPressActivated && distance > 30f) {
        isLongPressSliding = true
        handleLongPressSlide(deltaX)
    }
}

ACTION_UP -> {
    // 根据状态决定后续操作
    if (isLongPressActivated) {
        if (isLongPressSliding) {
            snapToNearestCardAndOpen()
        } else {
            selectCurrentCard()
        }
    }
}
```

### 坐标转换系统
```kotlin
// 将tab区域的触摸坐标转换为StackedCardPreview坐标
val location = IntArray(2)
browserWebViewContainer.getLocationOnScreen(location)
val previewLocation = IntArray(2)
preview.getLocationOnScreen(previewLocation)

val relativeX = location[0] - previewLocation[0] + event.x
val relativeY = location[1] - previewLocation[1] + event.y

// 创建相对坐标的触摸事件
val relativeEvent = MotionEvent.obtain(...)
preview.dispatchTouchEvent(relativeEvent)
```

### 状态重置机制
```kotlin
private fun resetActivationState() {
    isLongPressActivated = false
    isLongPressSliding = false
    isVerticalDragging = false
    isTracking = false
    centerCardOffsetY = 0f
}

// 在以下情况重置状态：
// 1. 卡片被选择后
// 2. 设置新的卡片数据时
// 3. 关闭卡片后
```

## 🎯 用户体验优势

### 操作明确性
- **长按激活**：明确的500ms时间阈值，避免误触
- **滑动控制**：只有激活后才能滑动，逻辑清晰
- **释放打开**：手指脱离立即响应，符合直觉

### 视觉反馈清晰
- **激活反馈**：悬浮卡片显示提供明确的激活确认
- **滑动反馈**：实时的卡片移动和缩放效果
- **对齐反馈**：200ms的平滑对齐动画

### 交互逻辑一致
- **顺序操作**：长按 → 滑动 → 释放，逻辑顺序清晰
- **状态管理**：每个状态都有明确的进入和退出条件
- **错误处理**：未激活状态下的操作会被忽略

## 🧪 测试方法

### 基础功能测试
1. **切换到搜索tab**
2. **长按底部导航栏**（调试模式）
3. **观察悬浮卡片显示**

### 长按激活测试
1. **在tab区域按下手指**
2. **保持500ms**：观察是否激活
3. **提前释放**：应该无响应

### 长按滑动测试
1. **长按激活后**
2. **继续保持按压并左右滑动**
3. **观察卡片跟随滑动**

### 手指脱离测试
1. **长按滑动到某张卡片**
2. **释放手指**
3. **观察自动对齐并打开**

### 向上滑动关闭测试
1. **长按激活后**
2. **向上滑动**：观察中心卡片向上移动
3. **超过阈值**：观察关闭效果

## 📋 调试信息

### 关键日志
```
StackedCardPreview: 触摸按下: (x, y)
StackedCardPreview: 开始长按检测，当前激活状态: false
StackedCardPreview: 长按激活成功！悬浮卡片已显示
StackedCardPreview: 开始长按水平滑动
StackedCardPreview: 长按滑动切换到卡片: 1
StackedCardPreview: 手指脱离屏幕，激活状态: true, 滑动状态: true
StackedCardPreview: 长按滑动结束，打开正中间的卡片
StackedCardPreview: 对齐完成，打开中间卡片: 1
```

## 🎉 总结

这个明确区分的悬浮卡片交互系统提供了：

1. **清晰的操作逻辑**：三个阶段明确分离，避免混淆
2. **直观的用户体验**：符合用户操作习惯的交互流程
3. **可靠的技术实现**：完善的状态管理和错误处理
4. **丰富的视觉反馈**：每个操作都有清晰的视觉确认

用户可以通过简单的"长按 → 滑动 → 释放"三步操作，轻松实现多任务网页的预览和切换！
