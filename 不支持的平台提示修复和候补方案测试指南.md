# 不支持的平台提示修复和候补方案测试指南

## 问题描述

用户反馈：为什么会有提示不支持的平台？是没有安装app吗？能否使用web搜索和faviconloader服务获取来作为候补方案？

## 问题分析

经过检查发现以下问题：

1. **"不支持的平台"提示来源**：
   - PlatformJumpManager.jumpToPlatform方法中，当平台名称不在PLATFORM_CONFIGS中时显示此提示
   - 动态应用（如微信、淘宝、知乎等）不在预设平台配置中

2. **缺少候补方案**：
   - 没有web搜索候补方案
   - 没有favicon loader服务
   - 应用未安装时无法提供替代方案

3. **动态应用处理不完善**：
   - 动态应用无法正确跳转
   - 缺少应用名称到包名的映射
   - 没有通用的URL scheme处理

## 修复内容

### 1. 修复"不支持的平台"提示问题

**修复前**：
```kotlin
fun jumpToPlatform(platformName: String, query: String) {
    val config = PLATFORM_CONFIGS[platformName]
    if (config == null) {
        Log.e(TAG, "未知平台: $platformName")
        Toast.makeText(context, "不支持的平台", Toast.LENGTH_SHORT).show()
        return
    }
    // ...
}
```

**修复后**：
```kotlin
fun jumpToPlatform(platformName: String, query: String) {
    val config = PLATFORM_CONFIGS[platformName]
    
    if (config != null) {
        // 预设平台，使用原有逻辑
        // ...
    } else {
        // 动态应用，使用通用跳转逻辑
        jumpToDynamicApp(platformName, query)
    }
}
```

### 2. 添加Web搜索候补方案

**新增功能**：
```kotlin
/**
 * 为动态应用使用Web搜索
 */
private fun jumpToWebSearchForDynamicApp(appName: String, query: String) {
    val cleanQuery = cleanQueryForSearch(query)
    
    // 根据应用名称选择最合适的搜索引擎
    val searchUrl = when {
        appName.contains("微信") -> "https://weixin.sogou.com/weixin?type=2&query=${Uri.encode(cleanQuery)}"
        appName.contains("淘宝") -> "https://s.taobao.com/search?q=${Uri.encode(cleanQuery)}"
        appName.contains("京东") -> "https://search.jd.com/Search?keyword=${Uri.encode(cleanQuery)}"
        appName.contains("知乎") -> "https://www.zhihu.com/search?q=${Uri.encode(cleanQuery)}"
        appName.contains("拼多多") -> "https://mobile.yangkeduo.com/search_result.html?search_key=${Uri.encode(cleanQuery)}"
        appName.contains("天猫") -> "https://list.tmall.com/search_product.htm?q=${Uri.encode(cleanQuery)}"
        appName.contains("QQ") -> "https://www.sogou.com/web?query=${Uri.encode(cleanQuery)}"
        else -> "https://www.google.com/search?q=${Uri.encode(cleanQuery)}+${Uri.encode(appName)}"
    }
    
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(searchUrl))
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    context.startActivity(intent)
}
```

### 3. 实现FaviconLoader服务

**新增FaviconLoader**：
```kotlin
object FaviconLoader {
    // 内存缓存
    private val memoryCache: LruCache<String, Bitmap>
    
    // 网站到favicon URL的映射
    private val faviconUrls = ConcurrentHashMap<String, List<String>>()
    
    /**
     * 加载favicon图标
     */
    fun loadFavicon(imageView: ImageView, url: String) {
        val domain = extractDomain(url)
        val cacheKey = "favicon_$domain"
        
        // 检查内存缓存
        val cachedBitmap = memoryCache.get(cacheKey)
        if (cachedBitmap != null) {
            imageView.setImageBitmap(cachedBitmap)
            return
        }
        
        // 异步加载favicon
        CoroutineScope(Dispatchers.IO).launch {
            val bitmap = loadFaviconFromUrl(domain)
            if (bitmap != null) {
                memoryCache.put(cacheKey, bitmap)
                withContext(Dispatchers.Main) {
                    if (imageView.tag == cacheKey) {
                        imageView.setImageBitmap(bitmap)
                    }
                }
            }
        }
    }
}
```

### 4. 集成FaviconLoader到PlatformIconLoader

**新增候补方案**：
```kotlin
/**
 * 尝试使用FaviconLoader获取图标
 */
private fun tryFaviconLoader(imageView: ImageView, appName: String, context: Context, cacheKey: String) {
    try {
        // 根据应用名称生成对应的网站URL
        val websiteUrl = generateWebsiteUrl(appName)
        if (websiteUrl != null) {
            FaviconLoader.loadFavicon(imageView, websiteUrl)
            Log.d(TAG, "Using FaviconLoader for $appName: $websiteUrl")
        }
    } catch (e: Exception) {
        Log.e(TAG, "Failed to load favicon for $appName: ${e.message}")
    }
}

/**
 * 根据应用名称生成对应的网站URL
 */
private fun generateWebsiteUrl(appName: String): String? {
    return when {
        appName.contains("微信") -> "https://weixin.sogou.com"
        appName.contains("淘宝") -> "https://s.taobao.com"
        appName.contains("京东") -> "https://search.jd.com"
        appName.contains("知乎") -> "https://www.zhihu.com"
        appName.contains("拼多多") -> "https://mobile.yangkeduo.com"
        appName.contains("天猫") -> "https://list.tmall.com"
        appName.contains("QQ") -> "https://www.qq.com"
        appName.contains("抖音") -> "https://www.douyin.com"
        appName.contains("小红书") -> "https://www.xiaohongshu.com"
        appName.contains("YouTube") -> "https://www.youtube.com"
        appName.contains("哔哩哔哩") -> "https://www.bilibili.com"
        appName.contains("快手") -> "https://www.kuaishou.com"
        appName.contains("微博") -> "https://weibo.com"
        appName.contains("豆瓣") -> "https://www.douban.com"
        else -> null
    }
}
```

## 技术实现

### 1. 动态应用跳转流程

```kotlin
/**
 * 跳转到动态应用
 * 提供web搜索和favicon loader候补方案
 */
private fun jumpToDynamicApp(appName: String, query: String) {
    try {
        // 1. 尝试通过包名跳转到应用
        val packageName = getPackageNameByAppName(appName)
        if (packageName != null && isAppInstalled(packageName)) {
            jumpToDynamicAppByPackage(packageName, query)
            return
        }
        
        // 2. 应用未安装或找不到包名，使用Web搜索
        jumpToWebSearchForDynamicApp(appName, query)
        
    } catch (e: Exception) {
        Log.e(TAG, "动态应用跳转失败: $appName", e)
        // 跳转失败，使用Web搜索作为备选方案
        jumpToWebSearchForDynamicApp(appName, query)
    }
}
```

### 2. 多层次图标获取

```kotlin
// PlatformIconLoader中的图标获取流程
private fun loadDynamicAppIcon(imageView: ImageView, appName: String, context: Context) {
    // 1. 优先使用已安装应用的真实图标
    val realIcon = packageInfo.applicationInfo.loadIcon(packageManager)
    val processedIcon = iconProcessor.processIcon(realIcon, IconProcessor.IconStyle.ROUNDED_SQUARE)
    
    // 2. 如果本地图标加载失败，尝试从App Store获取
    val appStoreManager = AppStoreIconManager.getInstance(context)
    appStoreManager.getAppStoreIcon(...) { appStoreIcon ->
        val processedIcon = iconProcessor.processIcon(appStoreIcon, IconProcessor.IconStyle.ROUNDED_SQUARE)
    }
    
    // 3. 如果App Store也失败，尝试使用预设图标资源
    tryPresetIconResource(imageView, appName, context, cacheKey)
    
    // 4. 最后尝试使用FaviconLoader
    tryFaviconLoader(imageView, appName, context, cacheKey)
}
```

### 3. Web搜索候补方案

```kotlin
// 根据应用类型选择最合适的搜索引擎
val searchUrl = when {
    appName.contains("微信") -> "https://weixin.sogou.com/weixin?type=2&query=${Uri.encode(cleanQuery)}"
    appName.contains("淘宝") -> "https://s.taobao.com/search?q=${Uri.encode(cleanQuery)}"
    appName.contains("京东") -> "https://search.jd.com/Search?keyword=${Uri.encode(cleanQuery)}"
    appName.contains("知乎") -> "https://www.zhihu.com/search?q=${Uri.encode(cleanQuery)}"
    appName.contains("拼多多") -> "https://mobile.yangkeduo.com/search_result.html?search_key=${Uri.encode(cleanQuery)}"
    appName.contains("天猫") -> "https://list.tmall.com/search_product.htm?q=${Uri.encode(cleanQuery)}"
    appName.contains("QQ") -> "https://www.sogou.com/web?query=${Uri.encode(cleanQuery)}"
    else -> "https://www.google.com/search?q=${Uri.encode(cleanQuery)}+${Uri.encode(appName)}"
}
```

## 测试步骤

### 1. 不支持的平台提示修复测试
1. **启用动态应用**
   - 进入软件tab，长按任意非预设应用（如微信、淘宝、知乎等）
   - 点击"添加到AI回复"
   - 确认显示"已添加到AI回复"提示

2. **发送AI问题**
   - 进入简易模式或聊天界面
   - 发送问题："推荐一些好用的应用"

3. **检查平台跳转**
   - 点击AI回复下方的动态应用图标
   - 确认不再显示"不支持的平台"提示
   - 验证应用跳转或web搜索功能

### 2. Web搜索候补方案测试
1. **应用未安装测试**
   - 卸载某个已启用的应用（如淘宝）
   - 点击该应用图标
   - 确认自动跳转到对应的web搜索页面

2. **不同应用类型测试**
   - 测试微信图标跳转到搜狗微信搜索
   - 测试淘宝图标跳转到淘宝搜索
   - 测试京东图标跳转到京东搜索
   - 测试知乎图标跳转到知乎搜索

3. **搜索关键词测试**
   - 发送问题："推荐一些好用的购物应用"
   - 点击淘宝图标
   - 确认跳转到淘宝搜索页面，关键词为"好用的购物应用"

### 3. FaviconLoader服务测试
1. **图标加载测试**
   - 启用动态应用
   - 发送AI问题
   - 检查图标是否显示网站favicon（不是默认链接图标）

2. **缓存机制测试**
   - 多次发送AI问题
   - 确认favicon加载速度快（已缓存）
   - 检查内存使用情况

3. **网络异常测试**
   - 断开网络连接
   - 发送AI问题
   - 确认图标仍能正常显示（使用本地缓存）

### 4. 多层次候补方案测试
1. **完整流程测试**
   - 启用动态应用
   - 发送AI问题
   - 检查图标获取流程：
     - 优先使用已安装应用的真实图标
     - 失败时尝试App Store图标
     - 失败时尝试预设图标资源
     - 最后使用FaviconLoader

2. **错误处理测试**
   - 模拟各种错误情况
   - 确认候补方案正常工作
   - 验证最终有图标显示（不是空白）

3. **性能测试**
   - 启用大量动态应用
   - 检查图标加载性能
   - 确认内存使用合理

### 5. 应用名称映射测试
1. **预设平台映射测试**
   - 测试"抖音" -> "com.ss.android.ugc.aweme"映射
   - 测试"小红书" -> "com.xingin.xhs"映射
   - 确认所有预设平台映射正确

2. **动态应用映射测试**
   - 测试通过包管理器查找应用名称
   - 验证映射机制的准确性
   - 检查映射失败时的处理

3. **映射性能测试**
   - 测试大量应用时的映射性能
   - 确认映射结果缓存机制
   - 验证映射查找效率

## 预期结果

### 1. 不支持的平台提示修复
- ✅ 不再显示"不支持的平台"提示
- ✅ 动态应用能够正确跳转
- ✅ 提供完善的候补方案

### 2. Web搜索候补方案
- ✅ 应用未安装时自动跳转到web搜索
- ✅ 根据应用类型选择最合适的搜索引擎
- ✅ 搜索关键词正确传递

### 3. FaviconLoader服务
- ✅ 动态应用显示网站favicon图标
- ✅ 智能缓存机制提高加载速度
- ✅ 网络异常时使用本地缓存

### 4. 多层次候补方案
- ✅ 完整的图标获取流程
- ✅ 完善的错误处理机制
- ✅ 最终确保有图标显示

### 5. 用户体验
- ✅ 无"不支持的平台"提示
- ✅ 应用未安装时提供web搜索
- ✅ 图标显示精致准确
- ✅ 跳转功能完整可用

## 技术特点

### 1. 智能跳转机制
- 优先使用应用内跳转
- 应用未安装时使用web搜索
- 完善的错误处理和回退机制

### 2. 多层次图标获取
- 已安装应用真实图标
- App Store高质量图标
- 预设图标资源
- FaviconLoader网站图标

### 3. 智能搜索引擎选择
- 根据应用类型选择最合适的搜索引擎
- 支持微信、淘宝、京东、知乎等主流平台
- 通用Google搜索作为最后备选

### 4. 完善的缓存机制
- 图标内存缓存
- Favicon预加载
- 智能缓存管理

## 注意事项
- 确保不再显示"不支持的平台"提示
- 验证web搜索候补方案正常工作
- 测试FaviconLoader图标加载
- 检查多层次候补方案完整性
- 验证应用名称映射准确性
- 确保错误处理完善
