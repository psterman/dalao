# 阅读模式自动目录解析方案实现总结

## 🎯 目标
在阅读模式下，无论是在目录页面还是在章节页面，都能自动解析并显示目录列表。

## ✅ 实现方案

### 1. 核心逻辑 (`NovelReaderManager.kt`)

#### A. 目录链接提取
在解析当前章节 (`parseCurrentChapter`) 时，注入的 JS 脚本现在会尝试寻找目录链接：
```javascript
function findCatalogLink() {
    var links = document.getElementsByTagName('a');
    for (var i = 0; i < links.length; i++) {
        var text = links[i].innerText;
        // 关键词匹配：目录、章节列表、Index
        if (text.indexOf('目录') > -1 || text.indexOf('章节列表') > -1 || text === 'Index') {
            return links[i].href;
        }
    }
    return "";
}
```
提取到的链接保存在 `catalogUrl` 变量中。

#### B. 目录获取与解析 (`fetchCatalog`)
当用户点击"目录"按钮时：
1. **如果存在 `catalogUrl`**：
   - 创建一个后台 `WebView` (`backgroundWebView`)。
   - 加载目录 URL。
   - 页面加载完成后，注入目录解析脚本。
2. **如果不存在 `catalogUrl`**：
   - 假设当前页面就是目录页（或者目录就在当前页）。
   - 直接在当前 `WebView` 中注入目录解析脚本。

#### C. 智能目录解析算法
注入的 JS 脚本 (`parseCatalogFromWebView`) 使用启发式算法寻找目录：
1. 遍历页面所有元素。
2. 寻找包含大量链接 (`<a>` 标签) 的容器。
3. 过滤链接：
   - 文本包含 "章"、"节" 或以数字开头。
   - 链接数量 > 5。
4. 选择包含最多有效章节链接的容器作为目录。
5. 返回章节列表 JSON (`[{title: "第一章...", url: "..."}, ...]`)。

### 2. UI 交互 (`NovelReaderUI.kt`)

#### A. 目录展示
- 实现 `onCatalogLoaded` 回调。
- 使用 `AlertDialog` 显示章节列表。
- 点击章节后调用 `manager.loadChapter(url)` 跳转。

#### B. 章节跳转处理
- `loadChapter` 会重置 `isLoadingNext` 状态并加载新 URL。
- `onChapterLoaded` 中增加了清理逻辑：
  - 如果不是追加模式（即跳转章节），会重置初始标题和内容。
  - 移除所有动态添加的章节视图（通过 `tag="dynamic_chapter"` 识别）。
  - 滚动回顶部。

## 📝 修改文件

1. **`app/src/main/java/com/example/aifloatingball/reader/NovelReaderManager.kt`**
   - 添加 `CatalogItem` 数据类。
   - 添加 `fetchCatalog`、`loadCatalogInBackground`、`parseCatalogFromWebView` 方法。
   - 更新 JS 脚本。

2. **`app/src/main/java/com/example/aifloatingball/reader/NovelReaderUI.kt`**
   - 实现 `onCatalogLoaded` 显示对话框。
   - 更新目录按钮点击事件。
   - 优化 `addChapterView` 和清理逻辑。

## 🚀 使用效果

1. **在章节页面**：
   - 点击"目录" -> 显示"加载中" -> 后台加载目录页 -> 弹出目录列表对话框 -> 点击跳转。
2. **在目录页面**（如果误入阅读模式）：
   - 点击"目录" -> 直接解析当前页 -> 弹出目录列表对话框。

## ⚠️ 注意事项
- 目录解析依赖于网页结构，对于某些特殊结构的网站可能无法完美识别。
- 后台加载目录页需要网络，速度取决于网速。
- 简单的启发式算法可能包含少量无效链接（如"下一页"），但已做过滤处理。
