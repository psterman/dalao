# æ”¶è—å†…å®¹å…³è”åŠŸèƒ½å®ç°æ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚æ¦‚è¿°

å®ç°æ”¶è—å†…å®¹ä¹‹é—´çš„ç›¸äº’å…³è”åŠŸèƒ½ï¼Œæ”¯æŒï¼š
- å•ä¸ªæ”¶è—é¡¹å¯ä»¥å…³è”å¤šä¸ªå…¶ä»–æ”¶è—é¡¹
- æ”¯æŒåŒå‘å…³è”
- æ”¯æŒå…³è”ç±»å‹ï¼ˆå¦‚ï¼šç›¸å…³ã€å¼•ç”¨ã€ä¾èµ–ã€åŒ…å«ç­‰ï¼‰
- å¯è§†åŒ–å±•ç¤ºä¸ºæ€ç»´å¯¼å›¾æˆ–Mermaidå›¾è¡¨
- æ”¯æŒå…³è”å…³ç³»çš„å¢åˆ æ”¹æŸ¥

---

## ğŸ¯ æ–¹æ¡ˆä¸€ï¼šæ•°æ®æ¨¡å‹å†…åµŒå…³è”å­—æ®µï¼ˆæ¨èç”¨äºå¿«é€Ÿå®ç°ï¼‰

### 1.1 æ•°æ®æ¨¡å‹è®¾è®¡

**ä¼˜ç‚¹ï¼š**
- å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–å­˜å‚¨
- æŸ¥è¯¢å…³è”é¡¹å¿«é€Ÿï¼ˆç›´æ¥è¯»å–å­—æ®µï¼‰
- æ•°æ®ä¸€è‡´æ€§å¥½ï¼ˆå…³è”å…³ç³»ä¸æ”¶è—é¡¹ä¸€èµ·å­˜å‚¨ï¼‰

**ç¼ºç‚¹ï¼š**
- åˆ é™¤æ”¶è—é¡¹æ—¶éœ€è¦æ¸…ç†æ‰€æœ‰å…³è”å¼•ç”¨
- ä¸æ”¯æŒå…³è”å…³ç³»çš„å…ƒæ•°æ®ï¼ˆå¦‚å…³è”æ—¶é—´ã€å…³è”ç±»å‹ç­‰ï¼‰
- å¤§æ•°æ®é‡æ—¶å¯èƒ½å½±å“æ€§èƒ½

**å®ç°æ–¹å¼ï¼š**

```kotlin
/**
 * å…³è”å…³ç³»ç±»å‹æšä¸¾
 */
enum class RelationType(val displayName: String, val icon: String) {
    RELATED("ç›¸å…³", "ğŸ”—"),
    REFERENCE("å¼•ç”¨", "ğŸ“"),
    DEPENDENCY("ä¾èµ–", "â¬‡ï¸"),
    CONTAINS("åŒ…å«", "ğŸ“¦"),
    SIMILAR("ç›¸ä¼¼", "ğŸ”€"),
    SEQUENCE("é¡ºåº", "â¡ï¸"),
    PARENT("çˆ¶çº§", "â¬†ï¸"),
    CHILD("å­çº§", "â¬‡ï¸")
}

/**
 * å…³è”å…³ç³»æ•°æ®æ¨¡å‹
 */
data class CollectionRelation(
    val targetId: String,              // å…³è”ç›®æ ‡ID
    val relationType: RelationType,    // å…³è”ç±»å‹
    val createdAt: Long = System.currentTimeMillis(),  // åˆ›å»ºæ—¶é—´
    val note: String? = null           // å…³è”å¤‡æ³¨
) : Serializable

/**
 * æ‰©å±•UnifiedCollectionItemï¼Œæ·»åŠ å…³è”å­—æ®µ
 */
data class UnifiedCollectionItem(
    // ... ç°æœ‰å­—æ®µ ...
    
    // å…³è”å…³ç³»ï¼ˆå­˜å‚¨å…³è”çš„å…¶ä»–æ”¶è—é¡¹IDå’Œç±»å‹ï¼‰
    val relations: List<CollectionRelation> = emptyList()
) : Serializable {
    
    /**
     * æ·»åŠ å…³è”å…³ç³»
     */
    fun addRelation(targetId: String, relationType: RelationType, note: String? = null): UnifiedCollectionItem {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å…³è”
        if (relations.any { it.targetId == targetId }) {
            return this
        }
        return copy(
            relations = relations + CollectionRelation(targetId, relationType, note = note)
        )
    }
    
    /**
     * ç§»é™¤å…³è”å…³ç³»
     */
    fun removeRelation(targetId: String): UnifiedCollectionItem {
        return copy(
            relations = relations.filter { it.targetId != targetId }
        )
    }
    
    /**
     * æ›´æ–°å…³è”ç±»å‹
     */
    fun updateRelationType(targetId: String, newType: RelationType): UnifiedCollectionItem {
        return copy(
            relations = relations.map {
                if (it.targetId == targetId) {
                    it.copy(relationType = newType)
                } else {
                    it
                }
            }
        )
    }
    
    /**
     * è·å–æ‰€æœ‰å…³è”çš„æ”¶è—é¡¹ID
     */
    fun getRelatedIds(): List<String> {
        return relations.map { it.targetId }
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦å…³è”äº†æŒ‡å®šID
     */
    fun isRelatedTo(targetId: String): Boolean {
        return relations.any { it.targetId == targetId }
    }
}
```

### 1.2 ç®¡ç†å™¨æ‰©å±•

```kotlin
class UnifiedCollectionManager {
    // ... ç°æœ‰æ–¹æ³• ...
    
    /**
     * æ·»åŠ å…³è”å…³ç³»ï¼ˆåŒå‘ï¼‰
     */
    fun addRelation(sourceId: String, targetId: String, relationType: RelationType, note: String? = null, bidirectional: Boolean = true): Boolean {
        val collections = getAllCollections().toMutableList()
        
        val sourceIndex = collections.indexOfFirst { it.id == sourceId }
        val targetIndex = collections.indexOfFirst { it.id == targetId }
        
        if (sourceIndex < 0 || targetIndex < 0) {
            Log.e(TAG, "å…³è”å¤±è´¥ï¼šæºæˆ–ç›®æ ‡æ”¶è—é¡¹ä¸å­˜åœ¨")
            return false
        }
        
        // é˜²æ­¢è‡ªå…³è”
        if (sourceId == targetId) {
            Log.e(TAG, "å…³è”å¤±è´¥ï¼šä¸èƒ½å…³è”è‡ªå·±")
            return false
        }
        
        // æ›´æ–°æºæ”¶è—é¡¹
        collections[sourceIndex] = collections[sourceIndex].addRelation(targetId, relationType, note)
        
        // åŒå‘å…³è”ï¼šæ›´æ–°ç›®æ ‡æ”¶è—é¡¹
        if (bidirectional) {
            val reverseType = getReverseRelationType(relationType)
            collections[targetIndex] = collections[targetIndex].addRelation(sourceId, reverseType, note)
        }
        
        return saveCollections(collections)
    }
    
    /**
     * ç§»é™¤å…³è”å…³ç³»ï¼ˆåŒå‘ï¼‰
     */
    fun removeRelation(sourceId: String, targetId: String, bidirectional: Boolean = true): Boolean {
        val collections = getAllCollections().toMutableList()
        
        val sourceIndex = collections.indexOfFirst { it.id == sourceId }
        val targetIndex = collections.indexOfFirst { it.id == targetId }
        
        if (sourceIndex < 0 || targetIndex < 0) {
            return false
        }
        
        // ç§»é™¤æºæ”¶è—é¡¹çš„å…³è”
        collections[sourceIndex] = collections[sourceIndex].removeRelation(targetId)
        
        // åŒå‘ç§»é™¤
        if (bidirectional) {
            collections[targetIndex] = collections[targetIndex].removeRelation(sourceId)
        }
        
        return saveCollections(collections)
    }
    
    /**
     * è·å–å…³è”çš„æ”¶è—é¡¹åˆ—è¡¨
     */
    fun getRelatedCollections(id: String): List<Pair<UnifiedCollectionItem, CollectionRelation>> {
        val item = getCollectionById(id) ?: return emptyList()
        return item.relations.mapNotNull { relation ->
            getCollectionById(relation.targetId)?.let { relatedItem ->
                Pair(relatedItem, relation)
            }
        }
    }
    
    /**
     * è·å–æ‰€æœ‰å…³è”çš„æ”¶è—é¡¹ï¼ˆé€’å½’ï¼Œå¯è®¾ç½®æ·±åº¦ï¼‰
     */
    fun getAllRelatedCollections(id: String, maxDepth: Int = 3): List<UnifiedCollectionItem> {
        val result = mutableSetOf<String>()
        val queue = mutableListOf<Pair<String, Int>>(Pair(id, 0))
        
        while (queue.isNotEmpty()) {
            val (currentId, depth) = queue.removeAt(0)
            
            if (depth >= maxDepth || currentId in result) {
                continue
            }
            
            result.add(currentId)
            val item = getCollectionById(currentId) ?: continue
            
            item.relations.forEach { relation ->
                if (relation.targetId !in result) {
                    queue.add(Pair(relation.targetId, depth + 1))
                }
            }
        }
        
        return result.filter { it != id }.mapNotNull { getCollectionById(it) }
    }
    
    /**
     * åˆ é™¤æ”¶è—é¡¹æ—¶æ¸…ç†æ‰€æœ‰å…³è”
     */
    override fun deleteCollection(id: String): Boolean {
        val collections = getAllCollections().toMutableList()
        
        // ç§»é™¤æ‰€æœ‰æŒ‡å‘è¯¥æ”¶è—é¡¹çš„å…³è”
        collections.forEachIndexed { index, item ->
            if (item.isRelatedTo(id)) {
                collections[index] = item.removeRelation(id)
            }
        }
        
        // åˆ é™¤æ”¶è—é¡¹æœ¬èº«
        val removed = collections.removeIf { it.id == id }
        
        if (removed) {
            return saveCollections(collections)
        }
        
        return false
    }
    
    /**
     * è·å–åå‘å…³è”ç±»å‹
     */
    private fun getReverseRelationType(type: RelationType): RelationType {
        return when (type) {
            RelationType.PARENT -> RelationType.CHILD
            RelationType.CHILD -> RelationType.PARENT
            RelationType.DEPENDENCY -> RelationType.DEPENDENCY  // ä¾èµ–å…³ç³»é€šå¸¸ä¹Ÿæ˜¯åŒå‘çš„
            else -> type  // å…¶ä»–ç±»å‹ä¿æŒåŸæ ·
        }
    }
    
    /**
     * æ£€æµ‹å¾ªç¯å…³è”
     */
    fun detectCircularRelation(sourceId: String, targetId: String): Boolean {
        // ä½¿ç”¨DFSæ£€æµ‹æ˜¯å¦å­˜åœ¨ä»targetIdåˆ°sourceIdçš„è·¯å¾„
        val visited = mutableSetOf<String>()
        val stack = mutableListOf(targetId)
        
        while (stack.isNotEmpty()) {
            val currentId = stack.removeAt(0)
            
            if (currentId == sourceId) {
                return true  // å‘ç°å¾ªç¯
            }
            
            if (currentId in visited) {
                continue
            }
            
            visited.add(currentId)
            val item = getCollectionById(currentId) ?: continue
            
            item.relations.forEach { relation ->
                if (relation.targetId !in visited) {
                    stack.add(relation.targetId)
                }
            }
        }
        
        return false
    }
}
```

---

## ğŸ¯ æ–¹æ¡ˆäºŒï¼šç‹¬ç«‹å…³è”å…³ç³»è¡¨ï¼ˆæ¨èç”¨äºå¤æ‚åœºæ™¯ï¼‰

### 2.1 æ•°æ®æ¨¡å‹è®¾è®¡

**ä¼˜ç‚¹ï¼š**
- å…³è”å…³ç³»ç‹¬ç«‹å­˜å‚¨ï¼Œä¾¿äºç®¡ç†
- æ”¯æŒå…³è”å…³ç³»çš„å…ƒæ•°æ®ï¼ˆåˆ›å»ºæ—¶é—´ã€åˆ›å»ºè€…ã€æƒé‡ç­‰ï¼‰
- æŸ¥è¯¢æ€§èƒ½æ›´å¥½ï¼ˆä¸“é—¨çš„å…³è”æŸ¥è¯¢ï¼‰
- æ”¯æŒå…³è”å…³ç³»çš„ç‰ˆæœ¬å†å²

**ç¼ºç‚¹ï¼š**
- éœ€è¦é¢å¤–çš„å­˜å‚¨ç©ºé—´
- éœ€è¦ç»´æŠ¤æ•°æ®ä¸€è‡´æ€§ï¼ˆåˆ é™¤æ”¶è—é¡¹æ—¶æ¸…ç†å…³è”ï¼‰
- å®ç°å¤æ‚åº¦ç¨é«˜

**å®ç°æ–¹å¼ï¼š**

```kotlin
/**
 * å…³è”å…³ç³»æ•°æ®æ¨¡å‹ï¼ˆç‹¬ç«‹å­˜å‚¨ï¼‰
 */
data class CollectionRelationEntity(
    val id: String = java.util.UUID.randomUUID().toString(),
    val sourceId: String,              // æºæ”¶è—é¡¹ID
    val targetId: String,              // ç›®æ ‡æ”¶è—é¡¹ID
    val relationType: RelationType,    // å…³è”ç±»å‹
    val weight: Float = 1.0f,          // å…³è”æƒé‡ï¼ˆ0-1ï¼‰
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis(),
    val note: String? = null,         // å…³è”å¤‡æ³¨
    val isBidirectional: Boolean = true  // æ˜¯å¦åŒå‘å…³è”
) : Serializable {
    
    /**
     * æ›´æ–°å…³è”ä¿¡æ¯
     */
    fun update(relationType: RelationType? = null, weight: Float? = null, note: String? = null): CollectionRelationEntity {
        return copy(
            relationType = relationType ?: this.relationType,
            weight = weight ?: this.weight,
            note = note ?: this.note,
            updatedAt = System.currentTimeMillis()
        )
    }
}

/**
 * å…³è”å…³ç³»ç®¡ç†å™¨
 */
class CollectionRelationManager private constructor(private val context: Context) {
    
    companion object {
        private const val TAG = "CollectionRelationManager"
        private const val PREFS_NAME = "collection_relations"
        private const val KEY_RELATIONS = "relations_list"
        
        @Volatile
        private var INSTANCE: CollectionRelationManager? = null
        
        fun getInstance(context: Context): CollectionRelationManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: CollectionRelationManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }
    
    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val gson = Gson()
    
    /**
     * è·å–æ‰€æœ‰å…³è”å…³ç³»
     */
    fun getAllRelations(): List<CollectionRelationEntity> {
        val json = prefs.getString(KEY_RELATIONS, "[]") ?: "[]"
        return try {
            val type = object : TypeToken<List<CollectionRelationEntity>>() {}.type
            gson.fromJson(json, type) ?: emptyList()
        } catch (e: Exception) {
            Log.e(TAG, "è§£æå…³è”å…³ç³»å¤±è´¥", e)
            emptyList()
        }
    }
    
    /**
     * æ·»åŠ å…³è”å…³ç³»
     */
    fun addRelation(
        sourceId: String,
        targetId: String,
        relationType: RelationType,
        weight: Float = 1.0f,
        note: String? = null,
        bidirectional: Boolean = true
    ): Boolean {
        if (sourceId == targetId) {
            Log.e(TAG, "ä¸èƒ½å…³è”è‡ªå·±")
            return false
        }
        
        val relations = getAllRelations().toMutableList()
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å…³è”
        val existingRelation = relations.find {
            (it.sourceId == sourceId && it.targetId == targetId) ||
            (bidirectional && it.sourceId == targetId && it.targetId == sourceId)
        }
        
        if (existingRelation != null) {
            Log.w(TAG, "å…³è”å…³ç³»å·²å­˜åœ¨")
            return false
        }
        
        // æ·»åŠ æ­£å‘å…³è”
        relations.add(
            CollectionRelationEntity(
                sourceId = sourceId,
                targetId = targetId,
                relationType = relationType,
                weight = weight,
                note = note,
                isBidirectional = bidirectional
            )
        )
        
        // æ·»åŠ åå‘å…³è”ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (bidirectional) {
            val reverseType = getReverseRelationType(relationType)
            relations.add(
                CollectionRelationEntity(
                    sourceId = targetId,
                    targetId = sourceId,
                    relationType = reverseType,
                    weight = weight,
                    note = note,
                    isBidirectional = bidirectional
                )
            )
        }
        
        return saveRelations(relations)
    }
    
    /**
     * ç§»é™¤å…³è”å…³ç³»
     */
    fun removeRelation(sourceId: String, targetId: String, bidirectional: Boolean = true): Boolean {
        val relations = getAllRelations().toMutableList()
        val sizeBefore = relations.size
        
        relations.removeAll { relation ->
            (relation.sourceId == sourceId && relation.targetId == targetId) ||
            (bidirectional && relation.sourceId == targetId && relation.targetId == sourceId)
        }
        
        if (relations.size < sizeBefore) {
            return saveRelations(relations)
        }
        
        return false
    }
    
    /**
     * æ›´æ–°å…³è”å…³ç³»
     */
    fun updateRelation(
        sourceId: String,
        targetId: String,
        relationType: RelationType? = null,
        weight: Float? = null,
        note: String? = null
    ): Boolean {
        val relations = getAllRelations().toMutableList()
        var updated = false
        
        relations.forEachIndexed { index, relation ->
            if (relation.sourceId == sourceId && relation.targetId == targetId) {
                relations[index] = relation.update(relationType, weight, note)
                updated = true
            }
        }
        
        if (updated) {
            return saveRelations(relations)
        }
        
        return false
    }
    
    /**
     * è·å–æŒ‡å®šæ”¶è—é¡¹çš„æ‰€æœ‰å…³è”
     */
    fun getRelationsByCollectionId(id: String): List<CollectionRelationEntity> {
        return getAllRelations().filter {
            it.sourceId == id || it.targetId == id
        }
    }
    
    /**
     * è·å–æŒ‡å®šæ”¶è—é¡¹çš„å‡ºå…³è”ï¼ˆä½œä¸ºæºï¼‰
     */
    fun getOutgoingRelations(id: String): List<CollectionRelationEntity> {
        return getAllRelations().filter { it.sourceId == id }
    }
    
    /**
     * è·å–æŒ‡å®šæ”¶è—é¡¹çš„å…¥å…³è”ï¼ˆä½œä¸ºç›®æ ‡ï¼‰
     */
    fun getIncomingRelations(id: String): List<CollectionRelationEntity> {
        return getAllRelations().filter { it.targetId == id }
    }
    
    /**
     * åˆ é™¤æ”¶è—é¡¹çš„æ‰€æœ‰å…³è”
     */
    fun removeAllRelationsByCollectionId(id: String): Int {
        val relations = getAllRelations().toMutableList()
        val sizeBefore = relations.size
        
        relations.removeAll { it.sourceId == id || it.targetId == id }
        
        val removedCount = sizeBefore - relations.size
        if (removedCount > 0) {
            saveRelations(relations)
        }
        
        return removedCount
    }
    
    /**
     * æ£€æµ‹å¾ªç¯å…³è”
     */
    fun detectCircularRelation(sourceId: String, targetId: String): Boolean {
        val relations = getAllRelations()
        val visited = mutableSetOf<String>()
        val stack = mutableListOf(targetId)
        
        while (stack.isNotEmpty()) {
            val currentId = stack.removeAt(0)
            
            if (currentId == sourceId) {
                return true
            }
            
            if (currentId in visited) {
                continue
            }
            
            visited.add(currentId)
            relations.filter { it.sourceId == currentId }.forEach { relation ->
                if (relation.targetId !in visited) {
                    stack.add(relation.targetId)
                }
            }
        }
        
        return false
    }
    
    /**
     * è·å–å…³è”è·¯å¾„ï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
     */
    fun getRelationPath(sourceId: String, targetId: String, maxDepth: Int = 5): List<String>? {
        val relations = getAllRelations()
        val queue = mutableListOf<Pair<String, List<String>>>(Pair(sourceId, listOf(sourceId)))
        val visited = mutableSetOf<String>()
        
        while (queue.isNotEmpty()) {
            val (currentId, path) = queue.removeAt(0)
            
            if (currentId == targetId) {
                return path
            }
            
            if (currentId in visited || path.size > maxDepth) {
                continue
            }
            
            visited.add(currentId)
            relations.filter { it.sourceId == currentId }.forEach { relation ->
                if (relation.targetId !in visited) {
                    queue.add(Pair(relation.targetId, path + relation.targetId))
                }
            }
        }
        
        return null
    }
    
    /**
     * ä¿å­˜å…³è”å…³ç³»
     */
    private fun saveRelations(relations: List<CollectionRelationEntity>): Boolean {
        return try {
            val json = gson.toJson(relations)
            prefs.edit().putString(KEY_RELATIONS, json).apply()
            Log.d(TAG, "ä¿å­˜å…³è”å…³ç³»æˆåŠŸ: ${relations.size} æ¡")
            true
        } catch (e: Exception) {
            Log.e(TAG, "ä¿å­˜å…³è”å…³ç³»å¤±è´¥", e)
            false
        }
    }
    
    /**
     * è·å–åå‘å…³è”ç±»å‹
     */
    private fun getReverseRelationType(type: RelationType): RelationType {
        return when (type) {
            RelationType.PARENT -> RelationType.CHILD
            RelationType.CHILD -> RelationType.PARENT
            else -> type
        }
    }
}
```

---

## ğŸ¯ æ–¹æ¡ˆä¸‰ï¼šåŸºäºå›¾æ•°æ®åº“ç»“æ„ï¼ˆæ¨èç”¨äºå¤§è§„æ¨¡æ•°æ®ï¼‰

### 3.1 æ•°æ®æ¨¡å‹è®¾è®¡

**ä¼˜ç‚¹ï¼š**
- é€‚åˆå¤æ‚çš„å…³è”æŸ¥è¯¢
- æ”¯æŒå›¾ç®—æ³•ï¼ˆæœ€çŸ­è·¯å¾„ã€ä¸­å¿ƒåº¦åˆ†æç­‰ï¼‰
- æ€§èƒ½ä¼˜ç§€ï¼ˆä¸“é—¨ä¼˜åŒ–çš„å›¾ç»“æ„ï¼‰

**ç¼ºç‚¹ï¼š**
- å®ç°å¤æ‚åº¦é«˜
- éœ€è¦é¢å¤–çš„å›¾ç®—æ³•åº“
- å­¦ä¹ æˆæœ¬è¾ƒé«˜

**å®ç°æ–¹å¼ï¼š**

```kotlin
/**
 * å›¾èŠ‚ç‚¹ï¼ˆæ”¶è—é¡¹ï¼‰
 */
data class GraphNode(
    val id: String,
    val item: UnifiedCollectionItem,
    val neighbors: MutableSet<String> = mutableSetOf()  // é‚»å±…èŠ‚ç‚¹ID
)

/**
 * å›¾è¾¹ï¼ˆå…³è”å…³ç³»ï¼‰
 */
data class GraphEdge(
    val sourceId: String,
    val targetId: String,
    val relationType: RelationType,
    val weight: Float = 1.0f,
    val properties: Map<String, Any> = emptyMap()
)

/**
 * æ”¶è—é¡¹å›¾ç®¡ç†å™¨
 */
class CollectionGraphManager private constructor(private val context: Context) {
    
    companion object {
        private const val TAG = "CollectionGraphManager"
        
        @Volatile
        private var INSTANCE: CollectionGraphManager? = null
        
        fun getInstance(context: Context): CollectionGraphManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: CollectionGraphManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }
    
    private val nodes = mutableMapOf<String, GraphNode>()
    private val edges = mutableListOf<GraphEdge>()
    private val collectionManager = UnifiedCollectionManager.getInstance(context)
    
    /**
     * åˆå§‹åŒ–å›¾ï¼ˆä»æ”¶è—ç®¡ç†å™¨åŠ è½½ï¼‰
     */
    fun initialize() {
        val collections = collectionManager.getAllCollections()
        collections.forEach { item ->
            nodes[item.id] = GraphNode(item.id, item)
        }
        
        // åŠ è½½å…³è”å…³ç³»ï¼ˆå¦‚æœä½¿ç”¨æ–¹æ¡ˆä¸€ï¼‰
        collections.forEach { item ->
            item.relations.forEach { relation ->
                addEdge(item.id, relation.targetId, relation.relationType)
            }
        }
    }
    
    /**
     * æ·»åŠ è¾¹
     */
    fun addEdge(sourceId: String, targetId: String, relationType: RelationType, weight: Float = 1.0f): Boolean {
        if (sourceId == targetId) return false
        
        val sourceNode = nodes[sourceId] ?: return false
        val targetNode = nodes[targetId] ?: return false
        
        // æ£€æŸ¥è¾¹æ˜¯å¦å·²å­˜åœ¨
        if (edges.any { it.sourceId == sourceId && it.targetId == targetId }) {
            return false
        }
        
        edges.add(GraphEdge(sourceId, targetId, relationType, weight))
        sourceNode.neighbors.add(targetId)
        targetNode.neighbors.add(sourceId)
        
        return true
    }
    
    /**
     * ç§»é™¤è¾¹
     */
    fun removeEdge(sourceId: String, targetId: String): Boolean {
        val removed = edges.removeAll { 
            (it.sourceId == sourceId && it.targetId == targetId) ||
            (it.sourceId == targetId && it.targetId == sourceId)
        }
        
        if (removed) {
            nodes[sourceId]?.neighbors?.remove(targetId)
            nodes[targetId]?.neighbors?.remove(sourceId)
        }
        
        return removed
    }
    
    /**
     * è·å–èŠ‚ç‚¹çš„æ‰€æœ‰é‚»å±…
     */
    fun getNeighbors(nodeId: String): List<UnifiedCollectionItem> {
        val node = nodes[nodeId] ?: return emptyList()
        return node.neighbors.mapNotNull { neighborId ->
            nodes[neighborId]?.item
        }
    }
    
    /**
     * ä½¿ç”¨BFSæŸ¥æ‰¾æœ€çŸ­è·¯å¾„
     */
    fun findShortestPath(sourceId: String, targetId: String): List<String>? {
        val queue = mutableListOf<Pair<String, List<String>>>(Pair(sourceId, listOf(sourceId)))
        val visited = mutableSetOf<String>()
        
        while (queue.isNotEmpty()) {
            val (currentId, path) = queue.removeAt(0)
            
            if (currentId == targetId) {
                return path
            }
            
            if (currentId in visited) continue
            visited.add(currentId)
            
            nodes[currentId]?.neighbors?.forEach { neighborId ->
                if (neighborId !in visited) {
                    queue.add(Pair(neighborId, path + neighborId))
                }
            }
        }
        
        return null
    }
    
    /**
     * è®¡ç®—èŠ‚ç‚¹çš„åº¦ï¼ˆå…³è”æ•°é‡ï¼‰
     */
    fun getNodeDegree(nodeId: String): Int {
        return nodes[nodeId]?.neighbors?.size ?: 0
    }
    
    /**
     * æŸ¥æ‰¾ä¸­å¿ƒèŠ‚ç‚¹ï¼ˆåº¦æœ€é«˜çš„èŠ‚ç‚¹ï¼‰
     */
    fun findCentralNodes(limit: Int = 10): List<Pair<String, Int>> {
        return nodes.map { (id, node) ->
            Pair(id, node.neighbors.size)
        }.sortedByDescending { it.second }.take(limit)
    }
    
    /**
     * æŸ¥æ‰¾ç¤¾åŒºï¼ˆä½¿ç”¨ç®€å•çš„è¿é€šåˆ†é‡ç®—æ³•ï¼‰
     */
    fun findCommunities(): List<Set<String>> {
        val visited = mutableSetOf<String>()
        val communities = mutableListOf<Set<String>>()
        
        nodes.keys.forEach { nodeId ->
            if (nodeId !in visited) {
                val community = mutableSetOf<String>()
                dfs(nodeId, visited, community)
                if (community.isNotEmpty()) {
                    communities.add(community)
                }
            }
        }
        
        return communities
    }
    
    private fun dfs(nodeId: String, visited: MutableSet<String>, community: MutableSet<String>) {
        if (nodeId in visited) return
        
        visited.add(nodeId)
        community.add(nodeId)
        
        nodes[nodeId]?.neighbors?.forEach { neighborId ->
            dfs(neighborId, visited, community)
        }
    }
}
```

---

## ğŸ¯ æ–¹æ¡ˆå››ï¼šåŸºäºæ ‡ç­¾çš„è‡ªåŠ¨å…³è”ï¼ˆæ¨èç”¨äºç®€å•åœºæ™¯ï¼‰

### 4.1 å®ç°æ€è·¯

**ä¼˜ç‚¹ï¼š**
- å®ç°æœ€ç®€å•
- æ— éœ€æ‰‹åŠ¨åˆ›å»ºå…³è”
- è‡ªåŠ¨å‘ç°ç›¸ä¼¼å†…å®¹

**ç¼ºç‚¹ï¼š**
- å…³è”ç²¾åº¦è¾ƒä½
- æ— æ³•è¡¨è¾¾å¤æ‚çš„å…³è”å…³ç³»
- æ ‡ç­¾ç›¸åŒä¸ä»£è¡¨å†…å®¹ç›¸å…³

**å®ç°æ–¹å¼ï¼š**

```kotlin
class UnifiedCollectionManager {
    // ... ç°æœ‰æ–¹æ³• ...
    
    /**
     * åŸºäºæ ‡ç­¾æŸ¥æ‰¾ç›¸å…³æ”¶è—é¡¹
     */
    fun findRelatedByTags(itemId: String, minCommonTags: Int = 1): List<UnifiedCollectionItem> {
        val item = getCollectionById(itemId) ?: return emptyList()
        val itemTags = item.customTags.toSet()
        
        if (itemTags.isEmpty()) {
            return emptyList()
        }
        
        return getAllCollections().filter { other ->
            other.id != itemId && other.customTags.intersect(itemTags).size >= minCommonTags
        }.sortedByDescending { other ->
            other.customTags.intersect(itemTags).size
        }
    }
    
    /**
     * åŸºäºå†…å®¹ç›¸ä¼¼åº¦æŸ¥æ‰¾ç›¸å…³æ”¶è—é¡¹ï¼ˆä½¿ç”¨ç®€å•çš„æ–‡æœ¬ç›¸ä¼¼åº¦ï¼‰
     */
    fun findRelatedByContent(itemId: String, similarityThreshold: Float = 0.3f): List<Pair<UnifiedCollectionItem, Float>> {
        val item = getCollectionById(itemId) ?: return emptyList()
        val itemWords = extractWords(item.title + " " + item.content)
        
        return getAllCollections().mapNotNull { other ->
            if (other.id == itemId) return@mapNotNull null
            
            val otherWords = extractWords(other.title + " " + other.content)
            val similarity = calculateJaccardSimilarity(itemWords, otherWords)
            
            if (similarity >= similarityThreshold) {
                Pair(other, similarity)
            } else {
                null
            }
        }.sortedByDescending { it.second }
    }
    
    /**
     * æå–å…³é”®è¯
     */
    private fun extractWords(text: String): Set<String> {
        return text.lowercase()
            .split(Regex("[\\s\\p{Punct}]+"))
            .filter { it.length > 1 }
            .toSet()
    }
    
    /**
     * è®¡ç®—Jaccardç›¸ä¼¼åº¦
     */
    private fun calculateJaccardSimilarity(set1: Set<String>, set2: Set<String>): Float {
        val intersection = set1.intersect(set2).size
        val union = set1.union(set2).size
        return if (union == 0) 0f else intersection.toFloat() / union.toFloat()
    }
}
```

---

## ğŸ¨ å¯è§†åŒ–æ–¹æ¡ˆ

### 5.1 æ€ç»´å¯¼å›¾è§†å›¾ï¼ˆä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼‰

**æ¨èåº“ï¼š**
- `com.github.PhilJay:MPAndroidChart`ï¼ˆå›¾è¡¨åº“ï¼Œå¯ç”¨äºç½‘ç»œå›¾ï¼‰
- `com.github.anastr:speedviewlib`ï¼ˆè‡ªå®šä¹‰Viewï¼‰
- è‡ªå®šä¹‰Canvasç»˜åˆ¶

**å®ç°ç¤ºä¾‹ï¼š**

```kotlin
/**
 * æ€ç»´å¯¼å›¾è§†å›¾
 */
class MindMapView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {
    
    private var nodes: List<MindMapNode> = emptyList()
    private var edges: List<MindMapEdge> = emptyList()
    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        textSize = 40f
        color = Color.BLACK
    }
    
    data class MindMapNode(
        val id: String,
        val title: String,
        val x: Float,
        val y: Float,
        val radius: Float = 60f,
        val color: Int = Color.BLUE
    )
    
    data class MindMapEdge(
        val sourceId: String,
        val targetId: String,
        val relationType: RelationType
    )
    
    fun setData(nodes: List<MindMapNode>, edges: List<MindMapEdge>) {
        this.nodes = nodes
        this.edges = edges
        invalidate()
    }
    
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        
        // ç»˜åˆ¶è¾¹
        edges.forEach { edge ->
            val sourceNode = nodes.find { it.id == edge.sourceId } ?: return@forEach
            val targetNode = nodes.find { it.id == edge.targetId } ?: return@forEach
            
            paint.color = getRelationColor(edge.relationType)
            paint.strokeWidth = 4f
            canvas.drawLine(sourceNode.x, sourceNode.y, targetNode.x, targetNode.y, paint)
        }
        
        // ç»˜åˆ¶èŠ‚ç‚¹
        nodes.forEach { node ->
            paint.color = node.color
            paint.style = Paint.Style.FILL
            canvas.drawCircle(node.x, node.y, node.radius, paint)
            
            paint.color = Color.WHITE
            paint.style = Paint.Style.STROKE
            paint.strokeWidth = 3f
            canvas.drawCircle(node.x, node.y, node.radius, paint)
            
            // ç»˜åˆ¶æ–‡æœ¬
            val textBounds = Rect()
            textPaint.getTextBounds(node.title, 0, node.title.length, textBounds)
            val textX = node.x - textBounds.width() / 2f
            val textY = node.y + textBounds.height() / 2f
            canvas.drawText(node.title, textX, textY, textPaint)
        }
    }
    
    private fun getRelationColor(type: RelationType): Int {
        return when (type) {
            RelationType.RELATED -> Color.BLUE
            RelationType.REFERENCE -> Color.GREEN
            RelationType.DEPENDENCY -> Color.RED
            RelationType.CONTAINS -> Color.MAGENTA
            else -> Color.GRAY
        }
    }
}
```

### 5.2 Mermaidå›¾è¡¨ç”Ÿæˆ

**å®ç°æ–¹å¼ï¼š**

```kotlin
/**
 * Mermaidå›¾è¡¨ç”Ÿæˆå™¨
 */
class MermaidGraphGenerator {
    
    /**
     * ç”ŸæˆMermaidæµç¨‹å›¾ä»£ç 
     */
    fun generateFlowchart(
        collections: List<UnifiedCollectionItem>,
        relations: List<CollectionRelationEntity>
    ): String {
        val sb = StringBuilder()
        sb.append("```mermaid\n")
        sb.append("graph TD\n")
        
        // ç”ŸæˆèŠ‚ç‚¹
        collections.forEach { item ->
            val nodeId = sanitizeId(item.id)
            val nodeLabel = sanitizeLabel(item.title)
            sb.append("    $nodeId[\"$nodeLabel\"]\n")
        }
        
        // ç”Ÿæˆè¾¹
        relations.forEach { relation ->
            val sourceId = sanitizeId(relation.sourceId)
            val targetId = sanitizeId(relation.targetId)
            val label = relation.relationType.displayName
            val style = getRelationStyle(relation.relationType)
            
            sb.append("    $sourceId -->|$label| $targetId\n")
            if (style.isNotEmpty()) {
                sb.append("    style $sourceId $style\n")
            }
        }
        
        sb.append("```\n")
        return sb.toString()
    }
    
    /**
     * ç”ŸæˆMermaidæ€ç»´å¯¼å›¾ä»£ç 
     */
    fun generateMindMap(
        rootId: String,
        collections: List<UnifiedCollectionItem>,
        relations: List<CollectionRelationEntity>
    ): String {
        val sb = StringBuilder()
        sb.append("```mermaid\n")
        sb.append("mindmap\n")
        sb.append("  root((æ ¹èŠ‚ç‚¹))\n")
        
        // æ„å»ºæ ‘ç»“æ„
        val rootItem = collections.find { it.id == rootId } ?: return ""
        sb.append("    ${sanitizeLabel(rootItem.title)}\n")
        
        // æ·»åŠ å­èŠ‚ç‚¹
        val children = relations.filter { it.sourceId == rootId }
        children.forEach { relation ->
            val childItem = collections.find { it.id == relation.targetId } ?: return@forEach
            sb.append("      ${sanitizeLabel(childItem.title)}\n")
        }
        
        sb.append("```\n")
        return sb.toString()
    }
    
    /**
     * ç”ŸæˆMermaidå…³ç³»å›¾ä»£ç 
     */
    fun generateEntityRelationshipDiagram(
        collections: List<UnifiedCollectionItem>,
        relations: List<CollectionRelationEntity>
    ): String {
        val sb = StringBuilder()
        sb.append("```mermaid\n")
        sb.append("erDiagram\n")
        
        collections.forEach { item ->
            val entityName = sanitizeLabel(item.title.take(20))
            sb.append("    ${entityName} {\n")
            sb.append("        string id\n")
            sb.append("        string title\n")
            sb.append("        string type\n")
            sb.append("    }\n")
        }
        
        relations.forEach { relation ->
            val sourceItem = collections.find { it.id == relation.sourceId } ?: return@forEach
            val targetItem = collections.find { it.id == relation.targetId } ?: return@forEach
            val sourceName = sanitizeLabel(sourceItem.title.take(20))
            val targetName = sanitizeLabel(targetItem.title.take(20))
            val relationLabel = relation.relationType.displayName
            
            sb.append("    $sourceName ||--o{ $targetName : \"$relationLabel\"\n")
        }
        
        sb.append("```\n")
        return sb.toString()
    }
    
    private fun sanitizeId(id: String): String {
        return id.replace(Regex("[^a-zA-Z0-9]"), "_")
    }
    
    private fun sanitizeLabel(label: String): String {
        return label.replace("\"", "'").replace("\n", " ")
    }
    
    private fun getRelationStyle(type: RelationType): String {
        return when (type) {
            RelationType.DEPENDENCY -> "fill:#ff9999"
            RelationType.REFERENCE -> "fill:#99ff99"
            RelationType.CONTAINS -> "fill:#9999ff"
            else -> ""
        }
    }
}
```

### 5.3 WebViewå±•ç¤ºMermaidå›¾è¡¨

```kotlin
/**
 * Mermaidå›¾è¡¨å±•ç¤ºActivity
 */
class MermaidGraphActivity : AppCompatActivity() {
    
    private lateinit var webView: WebView
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        webView = WebView(this)
        setContentView(webView)
        
        val rootId = intent.getStringExtra("root_id") ?: return
        
        val collectionManager = UnifiedCollectionManager.getInstance(this)
        val relationManager = CollectionRelationManager.getInstance(this)
        
        val collections = collectionManager.getAllCollections()
        val relations = relationManager.getAllRelations()
        
        val generator = MermaidGraphGenerator()
        val mermaidCode = generator.generateFlowchart(collections, relations)
        
        val html = """
            <!DOCTYPE html>
            <html>
            <head>
                <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
                <style>
                    body { margin: 0; padding: 20px; }
                    .mermaid { text-align: center; }
                </style>
            </head>
            <body>
                $mermaidCode
                <script>
                    mermaid.initialize({startOnLoad:true});
                </script>
            </body>
            </html>
        """.trimIndent()
        
        webView.settings.javaScriptEnabled = true
        webView.loadDataWithBaseURL(null, html, "text/html", "UTF-8", null)
    }
}
```

---

## ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”æ€»ç»“

| æ–¹æ¡ˆ | å¤æ‚åº¦ | æ€§èƒ½ | çµæ´»æ€§ | é€‚ç”¨åœºæ™¯ |
|------|--------|------|--------|----------|
| **æ–¹æ¡ˆä¸€ï¼šå†…åµŒå­—æ®µ** | â­â­ | â­â­â­â­ | â­â­â­ | å¿«é€Ÿå®ç°ï¼Œä¸­å°è§„æ¨¡æ•°æ® |
| **æ–¹æ¡ˆäºŒï¼šç‹¬ç«‹å…³ç³»è¡¨** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | å¤æ‚å…³è”ï¼Œéœ€è¦å…ƒæ•°æ® |
| **æ–¹æ¡ˆä¸‰ï¼šå›¾æ•°æ®åº“** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | å¤§è§„æ¨¡æ•°æ®ï¼Œå¤æ‚æŸ¥è¯¢ |
| **æ–¹æ¡ˆå››ï¼šæ ‡ç­¾å…³è”** | â­ | â­â­â­ | â­â­ | ç®€å•åœºæ™¯ï¼Œè‡ªåŠ¨å‘ç° |

---

## ğŸš€ æ¨èå®æ–½è·¯å¾„

### é˜¶æ®µä¸€ï¼šåŸºç¡€å®ç°ï¼ˆæ–¹æ¡ˆä¸€ï¼‰
1. æ‰©å±•`UnifiedCollectionItem`æ·»åŠ `relations`å­—æ®µ
2. æ‰©å±•`UnifiedCollectionManager`æ·»åŠ å…³è”ç®¡ç†æ–¹æ³•
3. å®ç°åŸºç¡€çš„å…³è”å¢åˆ æ”¹æŸ¥

### é˜¶æ®µäºŒï¼šå¯è§†åŒ–å®ç°
1. å®ç°Mermaidå›¾è¡¨ç”Ÿæˆå™¨
2. åœ¨WebViewä¸­å±•ç¤ºMermaidå›¾è¡¨
3. æ·»åŠ æ€ç»´å¯¼å›¾è§†å›¾ï¼ˆå¯é€‰ï¼‰

### é˜¶æ®µä¸‰ï¼šä¼˜åŒ–å‡çº§ï¼ˆæ–¹æ¡ˆäºŒï¼‰
1. å¦‚æœæ•°æ®é‡å¤§æˆ–éœ€è¦å¤æ‚æŸ¥è¯¢ï¼Œè¿ç§»åˆ°ç‹¬ç«‹å…³ç³»è¡¨
2. æ·»åŠ å…³è”å…³ç³»çš„å…ƒæ•°æ®æ”¯æŒ
3. å®ç°å…³è”è·¯å¾„æŸ¥æ‰¾ã€ç¤¾åŒºå‘ç°ç­‰åŠŸèƒ½

### é˜¶æ®µå››ï¼šé«˜çº§åŠŸèƒ½ï¼ˆæ–¹æ¡ˆä¸‰ï¼‰
1. å¦‚æœéœ€è¦å›¾ç®—æ³•æ”¯æŒï¼Œå®ç°å›¾æ•°æ®åº“ç»“æ„
2. æ·»åŠ ä¸­å¿ƒåº¦åˆ†æã€æœ€çŸ­è·¯å¾„ç­‰åŠŸèƒ½
3. å®ç°æ™ºèƒ½æ¨èï¼ˆåŸºäºå…³è”å…³ç³»ï¼‰

---

## ğŸ“ æ³¨æ„äº‹é¡¹

1. **æ•°æ®ä¸€è‡´æ€§**ï¼šåˆ é™¤æ”¶è—é¡¹æ—¶å¿…é¡»æ¸…ç†æ‰€æœ‰å…³è”å…³ç³»
2. **å¾ªç¯æ£€æµ‹**ï¼šæ·»åŠ å…³è”æ—¶æ£€æµ‹æ˜¯å¦å½¢æˆå¾ªç¯
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤§é‡å…³è”æ—¶è€ƒè™‘ä½¿ç”¨ç´¢å¼•æˆ–ç¼“å­˜
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›æ¸…æ™°çš„å…³è”å¯è§†åŒ–ç•Œé¢
5. **æ•°æ®è¿ç§»**ï¼šå¦‚æœåˆ‡æ¢æ–¹æ¡ˆï¼Œéœ€è¦æä¾›æ•°æ®è¿ç§»å·¥å…·

